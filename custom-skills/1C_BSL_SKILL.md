---
name: 1c-bsl-code-generation
description: Skill for generating 1C:Enterprise (BSL) code with mandatory validation through MCP tools to prevent hallucinations. Use when generating, editing, or validating 1C BSL code, working with 1C metadata, or answering questions about 1C platform API.
---

# 1C BSL Code Generation with Anti-Hallucination Validation

## Introduction & When to Use

This skill provides mandatory procedures for generating 1C:Enterprise (BSL) code with strict validation to prevent hallucinations and ensure code correctness.

**Trigger this skill when:**
- Generating, editing, or validating 1C BSL code
- Working with 1C metadata objects (–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏, –î–æ–∫—É–º–µ–Ω—Ç—ã, –†–µ–≥–∏—Å—Ç—Ä—ã, etc.)
- Using 1C platform API
- Writing 1C Query Language code
- Answering questions about 1C platform capabilities

**Keywords for detection:**
- `1—Å`, `bsl`, `1c:enterprise`, `—Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫`, `–¥–æ–∫—É–º–µ–Ω—Ç`, `—Ä–µ–≥–∏—Å—Ç—Ä`, `—è–∑—ã–∫ –∑–∞–ø—Ä–æ—Å–æ–≤`
- `catalog`, `document`, `register`, `query language`

**Semantic triggers:**
- Creating/editing/validating BSL code
- Working with 1C configuration metadata
- Implementing 1C business logic
- Writing procedures/functions in BSL

---

## üö® CRITICAL: Absolute Compliance Requirements

**‚ö†Ô∏è THESE RULES ARE NON-NEGOTIABLE AND MUST BE FOLLOWED WITHOUT EXCEPTION ‚ö†Ô∏è**

**Failure to follow these rules constitutes a CRITICAL ERROR and produces hallucinated, potentially broken code.**

### Core Anti-Hallucination Principles

**MANDATORY RULES - NO EXCEPTIONS ALLOWED:**

#### 1. üö´ NEVER ASSUME 1C API EXISTS

- **PROHIBITION**: Writing ANY platform API call without validation
- **MANDATORY ACTION**: ALWAYS call `getMembers()` BEFORE using any method/property
- **CONSEQUENCE**: Hallucinated methods that don't exist = broken code
- **ENFORCEMENT**: If API not validated ‚Üí STOP and validate first

#### 2. üö´ NEVER ASSUME METADATA EXISTS

- **PROHIBITION**: Using metadata objects (–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏.*, –î–æ–∫—É–º–µ–Ω—Ç—ã.*, etc.) without verification
- **MANDATORY ACTION**: ALWAYS verify through `search_metadata` or `search_metadata_by_description`
- **CONSEQUENCE**: References to non-existent objects = runtime errors
- **ENFORCEMENT**: If metadata not verified ‚Üí STOP and verify first

#### 3. üö´ NEVER WRITE CODE FROM SCRATCH IF PATTERN EXISTS

- **PROHIBITION**: Writing new implementations without searching for existing patterns
- **MANDATORY ACTION**: ALWAYS call `search_code()` FIRST before writing new code
- **CONSEQUENCE**: Duplicate code, missed best practices, inconsistent patterns
- **ENFORCEMENT**: If pattern search not performed ‚Üí STOP and search first

#### 4. ‚úÖ ALWAYS VALIDATE BEFORE WRITE

- **REQUIREMENT**: Complete validation workflow BEFORE writing ANY .bsl file
- **MANDATORY CHECKS**: API validated + Metadata verified + Patterns searched
- **CONSEQUENCE**: Skip validation = high probability of errors
- **ENFORCEMENT**: Cannot proceed to file write without completed validation

#### 5. ‚úÖ ALWAYS LINT AFTER WRITE

- **REQUIREMENT**: Run `read_lints()` IMMEDIATELY after writing ANY .bsl file
- **MANDATORY FIX**: Fix ALL critical errors before proceeding
- **CONSEQUENCE**: Linter errors left unfixed = broken code in repository
- **ENFORCEMENT**: 0 critical errors required, max 3 fix attempts, then escalate to user

### üî¥ CRITICAL ENFORCEMENT POLICY

- These rules are NOT suggestions or recommendations
- These rules are ABSOLUTE REQUIREMENTS
- Agent MUST NOT skip any validation step
- Agent MUST NOT proceed if validation fails
- Agent MUST STOP and report if unable to validate

**Violation examples that are STRICTLY FORBIDDEN:**

```
‚ùå "I'll write the code quickly without checking API"
‚ùå "I assume this method exists based on similar patterns"
‚ùå "I'll skip search_code() because I know the pattern"
‚ùå "Linter check can be done later"
‚ùå "This is simple code, doesn't need validation"
```

**Correct approach - MANDATORY statements:**

```
‚úÖ "BEFORE writing code, I MUST validate API via getMembers()"
‚úÖ "BEFORE using metadata, I MUST verify via search_metadata()"
‚úÖ "BEFORE implementing, I MUST search existing patterns via search_code()"
‚úÖ "AFTER writing file, I MUST run read_lints() immediately"
‚úÖ "IF validation fails, I MUST STOP and resolve before proceeding"
```

---

## MCP Tools Reference

### A. API Validation Tools (`mcp_bsl-platform-context_*`)

**Usage strategy: Proactive validation BEFORE code generation + Reactive fixes AFTER linter errors**

#### PROACTIVE Tools (use BEFORE writing code)

##### 1. getMembers - Get ALL members of a type

- **When**: BEFORE generating code that uses platform types
- **Purpose**: Understand available methods/properties of a type
- **Syntax**: `bsl-platform-context.getMembers(typeName: "TypeName")`
- **Example**: `getMembers("–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–ú–µ–Ω–µ–¥–∂–µ—Ä")` ‚Üí list all catalog manager methods
- **Use case**: "I need to work with –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ ‚Üí check what methods are available"
- **Critical**: Call this FIRST to avoid hallucinating non-existent methods

**Example call:**
```json
{
  "typeName": "–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–û–±—ä–µ–∫—Ç"
}
```

**Expected result**: List of all methods and properties available for the type

##### 2. getConstructors - Get constructors for a type

- **When**: Need detailed description of class constructor
- **Purpose**: Understand how to create instances of a type
- **Syntax**: `bsl-platform-context.getConstructors(typeName: "TypeName")`
- **Example**: `getConstructors("–¢–∞–±–ª–∏—Ü–∞–ó–Ω–∞—á–µ–Ω–∏–π")` ‚Üí how to create ValueTable
- **Use case**: Creating new objects, need to know constructor signatures

**Example call:**
```json
{
  "typeName": "–¢–∞–±–ª–∏—Ü–∞–ó–Ω–∞—á–µ–Ω–∏–π"
}
```

**Expected result**: List of available constructors with parameters

#### REACTIVE Tools (use AFTER linter errors)

##### 3. search - Search API by description

- **When**: Linter reports unknown method/property AND need to find alternatives
- **Purpose**: Find correct method name when linter says current one doesn't exist
- **Syntax**: `bsl-platform-context.search(query: "description", type: "method|property|type", limit: 10)`
- **Example**: Linter error "Method '–ù–∞–π—Ç–∏–ü–æ–ö–æ–¥—É' not found" ‚Üí search with query "find catalog by code"

**Example call:**
```json
{
  "query": "find by code",
  "type": "method",
  "limit": 10
}
```

##### 4. getMember - Get specific member details

- **When**: Linter reports error with specific method/property
- **Purpose**: Verify exact signature and parameters of a member
- **Syntax**: `bsl-platform-context.getMember(typeName: "Type", memberName: "Member")`
- **Parameters**: typeName, memberName
- **Example**: Linter error on `–ó–∞–ø–∏—Å–∞—Ç—å()` ‚Üí `getMember("–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–û–±—ä–µ–∫—Ç", "–ó–∞–ø–∏—Å–∞—Ç—å")`

**Example call:**
```json
{
  "typeName": "–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–û–±—ä–µ–∫—Ç",
  "memberName": "–ó–∞–ø–∏—Å–∞—Ç—å"
}
```

##### 5. info - Detailed information about API element

- **When**: Linter error AND need full documentation
- **Purpose**: Get complete documentation for troubleshooting
- **Syntax**: `bsl-platform-context.info(name: "ElementName", type: "method|property|type")`
- **Parameters**: name (exact name), type (method/property/type)
- **Example**: Complex linter error ‚Üí `info("–ù–∞–π—Ç–∏–ü–æ–°—Å—ã–ª–∫–µ", "method")` for full docs

**Example call:**
```json
{
  "name": "–ù–∞–π—Ç–∏–ü–æ–°—Å—ã–ª–∫–µ",
  "type": "method"
}
```

#### API Validation Workflow

**BEFORE code generation (proactive):**

```
1. Identify platform types used in task (–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–ú–µ–Ω–µ–¥–∂–µ—Ä, –î–æ–∫—É–º–µ–Ω—Ç–û–±—ä–µ–∫—Ç, etc.)
2. For EACH type:
   ‚îú‚îÄ Call getMembers(type) ‚Üí get available methods/properties
   ‚îî‚îÄ If creating instances ‚Üí call getConstructors(type)
3. Select correct methods from validated list
4. Write code using ONLY validated API
```

**AFTER linter errors (reactive):**

```
If linter reports API errors:
1. Identify error type:
   ‚îú‚îÄ Unknown method/property ‚Üí use search() to find correct name
   ‚îú‚îÄ Wrong signature ‚Üí use getMember() to verify parameters
   ‚îî‚îÄ Complex error ‚Üí use info() for full documentation
2. Fix code with correct API
3. Re-run linter
```

---

### B. Metadata Validation Tools (`mcp_1c-metacode_*`)

**Priority order of tool usage:**

1. **search_code** (PRIMARY) - ALWAYS search for existing patterns FIRST
2. **search_metadata_by_description** - when uncertain about metadata names
3. **search_metadata** - for structural queries and finding usage

#### 1. search_code - Finding existing code patterns (PRIMARY TOOL)

- **CRITICAL**: Use FIRST before writing any new code
- **Purpose**: Find existing implementations, procedures, functions to reuse
- **Query language**: RUSSIAN only (–∫—Ä–∏—Ç–∏—á–Ω–æ!)
- **Parameter** `is_ssl_api: true` for –ë–°–ü/SSL (standard subsystems library) code
- **Operations**:
  - `find_routines_by_description` - search by description
  - `get_routine_body` - get full procedure/function body

**Template JSON format (mandatory):**
```json
{
  "op": "find_routines_by_description",
  "text": "–∑–∞–ø–∏—Å—å —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞",
  "is_ssl_api": false,
  "limit": 50
}
```

**Examples:**
- "–∑–∞–ø–∏—Å—å —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞" ‚Üí find existing catalog write patterns
- "–ø—Ä–æ–≤–µ–¥–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞" ‚Üí find document posting patterns
- "—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏–π" ‚Üí find register movement patterns
- "—Ä–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏" with `is_ssl_api: true` ‚Üí find SSL file handling routines

**When to use:**
- ALWAYS before writing new procedure/function
- When implementing common patterns (write, post, validate, etc.)
- When working with –ë–°–ü/SSL functionality

#### 2. search_metadata_by_description - Semantic metadata search

- **When to use**: Agent is UNCERTAIN about exact metadata object names
- **Purpose**: Find objects by business description/purpose
- **Query**: Natural language description in Russian
- **Template JSON format (mandatory):**

```json
{
  "op": "search_metadata_by_description",
  "text": "—Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –±–∞–Ω–∫–æ–≤—Å–∫–∏—Ö —Å—á–µ—Ç–æ–≤",
  "categories": ["–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏"],
  "limit": 50
}
```

**Examples:**
- "—Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –±–∞–Ω–∫–æ–≤—Å–∫–∏—Ö —Å—á–µ—Ç–æ–≤" ‚Üí find bank account catalogs
- "–¥–æ–∫—É–º–µ–Ω—Ç—ã –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–æ–≤" ‚Üí find goods receipt documents
- "—Ä–µ–≥–∏—Å—Ç—Ä—ã —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Ü–µ–Ω–∞—Ö" ‚Üí find price information registers

**Use case**: When user mentions business entity but exact 1C object name is unknown

#### 3. search_metadata - Structural queries

**Purpose:**
- Get object structure (attributes, tabular parts, etc.)
- Find objects that USE specific attribute/resource/dimension

**Template JSON mode (MANDATORY!)**

**Key operations:**

##### object_structure - Get full structure
```json
{
  "op": "object_structure",
  "object": "–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã"
}
```
Returns: attributes, tabular parts, resources, dimensions

##### list_attributes - Get object attributes
```json
{
  "op": "list_attributes",
  "object": "–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã",
  "limit": 500
}
```

##### list_tabular_attributes - Get tabular section attributes
```json
{
  "op": "list_tabular_attributes",
  "object": "–°—á—ë—Ç",
  "tabular": "–ü–æ–∑–∏—Ü–∏–∏",
  "limit": 500
}
```

##### find_objects_by_attribute - Find objects using specific attribute
```json
{
  "op": "find_objects_by_attribute",
  "attr": "–ò–ù–ù",
  "match": "contains",
  "limit": 500
}
```

##### find_objects_by_resource - Find objects using specific resource
```json
{
  "op": "find_objects_by_resource",
  "resource": "–°—É–º–º–∞",
  "match": "exact",
  "limit": 500
}
```

##### find_objects_by_dimension - Find objects using specific dimension
```json
{
  "op": "find_objects_by_dimension",
  "dimension": "–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç",
  "match": "exact",
  "limit": 500
}
```

##### find_objects_using_object - Find where object is used as attribute/resource/dimension
```json
{
  "op": "find_objects_using_object",
  "target": "–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã",
  "match": "exact",
  "in_category": "–î–æ–∫—É–º–µ–Ω—Ç—ã",
  "include_tabular": true,
  "limit": 500
}
```

##### find_usages_of_object - Find usage sites (full paths)
```json
{
  "op": "find_usages_of_object",
  "target": "–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã",
  "match": "exact",
  "limit": 500
}
```
Returns 1C-style paths like:
- "–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏.–ù–æ–º–µ–Ω–∫–ª–∞—Ç—É—Ä–∞.–†–µ–∫–≤–∏–∑–∏—Ç—ã.–í–ª–∞–¥–µ–ª–µ—Ü"
- "–î–æ–∫—É–º–µ–Ω—Ç—ã.–°—á—ë—Ç.–¢–∞–±–ª–∏—á–Ω—ã–µ–ß–∞—Å—Ç–∏.–ü–æ–∑–∏—Ü–∏–∏.–†–µ–∫–≤–∏–∑–∏—Ç—ã.–ù–æ–º–µ–Ω–∫–ª–∞—Ç—É—Ä–∞"

**Critical use case**: "Find all documents that use –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫.–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã" ‚Üí use `find_objects_using_object`

#### Metadata Validation Workflow

```
Step 1: Pattern Search (PRIMARY - do this FIRST!)
‚îî‚îÄ Call search_code() with task description in RUSSIAN
   ‚îî‚îÄ If patterns found ‚Üí use as foundation for implementation

Step 2: If uncertain about metadata names
‚îî‚îÄ Call search_metadata_by_description() in RUSSIAN
   ‚îî‚îÄ Identify correct object names

Step 3: Structural validation
‚îú‚îÄ Call search_metadata(op: "object_structure") ‚Üí get full structure
‚îî‚îÄ Validate that required attributes/tabular parts exist

Step 4: Find usage (if needed)
‚îú‚îÄ find_objects_by_attribute() ‚Üí "What uses this attribute?"
‚îú‚îÄ find_objects_by_resource() ‚Üí "What uses this resource?"
‚îú‚îÄ find_objects_by_dimension() ‚Üí "What uses this dimension?"
‚îî‚îÄ find_objects_using_object() ‚Üí "What references this object?"

Step 5: Write code based on validated patterns and metadata
```

---

### C. Code Validation Tools

#### Error Severity Levels (for Cursor Linter)

**CRITICAL**: 
- **Definition**: Errors that MUST be fixed before code can be considered complete
- **Examples**: Syntax errors, undefined variables, type mismatches, missing required methods
- **Requirement**: 0 critical errors MANDATORY for completion

**WARNING**:
- **Definition**: Issues that should be addressed but don't break functionality
- **Examples**: Unused variables, deprecated methods, code style violations
- **Requirement**: Review warnings, fix if reasonable, document if left unfixed

**INFO**:
- **Definition**: Informational messages and suggestions
- **Examples**: Code optimization hints, alternative approaches
- **Requirement**: Optional to address

**For this skill**: "0 critical errors" means zero CRITICAL-level errors. Warnings and info messages should be reviewed but don't block completion.

#### 1. Cursor Linter (read_lints) - Primary validation

- **When**: AFTER writing EVERY file (PRIMARY CHECK - always run first)
- **Purpose**: Check for syntax and semantic errors via BSL Language Server
- **Success criteria**: 0 CRITICAL-level errors
- **Process**: If CRITICAL errors found ‚Üí analyze ‚Üí fix ‚Üí write corrected file ‚Üí re-run linter

**Example call:**
```python
read_lints(["path/to/file.bsl"])
```

**Auto-fix loop:**
```
1. Write BSL file
2. Call read_lints([file_path])
3. Analyze results by severity:
   ‚îú‚îÄ CRITICAL errors found:
   ‚îÇ  ‚îú‚îÄ Analyze error messages
   ‚îÇ  ‚îú‚îÄ Determine fixes
   ‚îÇ  ‚îú‚îÄ Apply fixes to code
   ‚îÇ  ‚îú‚îÄ Write corrected file
   ‚îÇ  ‚îî‚îÄ Repeat from step 2 (max 3 attempts)
   ‚îú‚îÄ Only WARNING/INFO found:
   ‚îÇ  ‚îî‚îÄ Proceed to additional validation (acceptable state)
   ‚îî‚îÄ No issues:
      ‚îî‚îÄ Proceed to additional validation
4. If CRITICAL errors remain after 3 attempts ‚Üí escalate to user
```

#### 2. 1c-copilot-proxy.check_1c_code - Additional validation

- **When**: AFTER linter check passes (secondary check)
- **Purpose**: Additional syntax/logic validation through 1C AI assistant
- **Parameters**: 
  - `code` (text of code to check)
  - `check_type` (default: "syntax", options: "syntax", "logic", "performance")
- **Types of checks**:
  - `syntax` - syntax errors (additional to linter)
  - `logic` - logical errors and potential bugs
  - `performance` - performance issues

**Example call:**
```json
{
  "code": "–ü—Ä–æ—Ü–µ–¥—É—Ä–∞ –ü–µ—Ä–µ–¥–ó–∞–ø–∏—Å—å—é(–û—Ç–∫–∞–∑)\n  // code here\n–ö–æ–Ω–µ—Ü–ü—Ä–æ—Ü–µ–¥—É—Ä—ã",
  "check_type": "syntax"
}
```

---

## Mandatory Validation Workflow

### BEFORE Writing Any BSL Code

**Complete this workflow BEFORE file write - NO EXCEPTIONS:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Step 1: Pattern Search (PRIMARY - MUST do FIRST!)          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ IF task involves common pattern:                            ‚îÇ
‚îÇ   1. Call search_code() with description in RUSSIAN        ‚îÇ
‚îÇ   2. Review found patterns                                  ‚îÇ
‚îÇ   3. IF suitable pattern exists:                            ‚îÇ
‚îÇ      ‚îî‚îÄ Use as foundation (modify as needed)               ‚îÇ
‚îÇ   4. IF no pattern found:                                   ‚îÇ
‚îÇ      ‚îî‚îÄ Proceed to Step 2 (create new implementation)      ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ COMMON PATTERNS (always search first):                      ‚îÇ
‚îÇ  ‚Ä¢ Catalog write/read (–∑–∞–ø–∏—Å—å/—á—Ç–µ–Ω–∏–µ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞)          ‚îÇ
‚îÇ  ‚Ä¢ Document posting (–ø—Ä–æ–≤–µ–¥–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞)                  ‚îÇ
‚îÇ  ‚Ä¢ Register movements (—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏–π)               ‚îÇ
‚îÇ  ‚Ä¢ Data validation (–ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö)                        ‚îÇ
‚îÇ  ‚Ä¢ Query construction (–ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞)                  ‚îÇ
‚îÇ  ‚Ä¢ File operations (—Ä–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏)                       ‚îÇ
‚îÇ  ‚Ä¢ Report generation (—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç—á—ë—Ç–∞)                  ‚îÇ
‚îÇ  ‚Ä¢ Exchange/integration (–æ–±–º–µ–Ω –¥–∞–Ω–Ω—ã–º–∏)                     ‚îÇ
‚îÇ  ‚Ä¢ Scheduled jobs (—Ä–µ–≥–ª–∞–º–µ–Ω—Ç–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è)                    ‚îÇ
‚îÇ  ‚Ä¢ Form event handlers (–æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π —Ñ–æ—Ä–º)           ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ IF task NOT in common patterns list:                        ‚îÇ
‚îÇ  ‚îî‚îÄ Still run search_code() with task description          ‚îÇ
‚îÇ     (may find relevant reusable code)                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Step 2: API Validation (for EVERY platform API call)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ FOR EACH platform API usage:                                ‚îÇ
‚îÇ   1. Identify object type (–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–ú–µ–Ω–µ–¥–∂–µ—Ä,             ‚îÇ
‚îÇ      –î–æ–∫—É–º–µ–Ω—Ç–û–±—ä–µ–∫—Ç, etc.)                                  ‚îÇ
‚îÇ   2. Call getMembers(type)                                  ‚îÇ
‚îÇ   3. Verify method/property exists in returned list         ‚îÇ
‚îÇ   4. IF creating instances:                                 ‚îÇ
‚îÇ      ‚îî‚îÄ Call getConstructors(type)                         ‚îÇ
‚îÇ   5. IF method/property NOT found:                          ‚îÇ
‚îÇ      ‚îú‚îÄ STOP code generation                               ‚îÇ
‚îÇ      ‚îî‚îÄ Report to user with available alternatives         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Step 3: Metadata Validation (for EVERY metadata usage)     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ FOR EACH metadata object (–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏.*, –î–æ–∫—É–º–µ–Ω—Ç—ã.*, etc.):‚îÇ
‚îÇ   1. IF exact name unknown:                                 ‚îÇ
‚îÇ      ‚îî‚îÄ Call search_metadata_by_description() in RUSSIAN   ‚îÇ
‚îÇ   2. Call search_metadata(op: "object_structure")          ‚îÇ
‚îÇ   3. Verify required attributes/tabular parts exist         ‚îÇ
‚îÇ   4. IF attribute/tabular part NOT found:                   ‚îÇ
‚îÇ      ‚îú‚îÄ STOP code generation                               ‚îÇ
‚îÇ      ‚îî‚îÄ Report to user with actual structure               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Step 4: Write Code (ONLY after validation complete)        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   1. Write file with validated code                         ‚îÇ
‚îÇ   2. Use ONLY validated API                                 ‚îÇ
‚îÇ   3. Use ONLY verified metadata                             ‚îÇ
‚îÇ   4. Follow pattern if found in Step 1                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**ENFORCEMENT:** Agent MUST NOT write file until Steps 1-3 are complete. If validation fails ‚Üí STOP and report to user.

### AFTER Writing BSL File

**Complete this workflow IMMEDIATELY after file write - NO EXCEPTIONS:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Step 5: Linter Check (MANDATORY PRIMARY CHECK)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   1. Call read_lints([file_path])                           ‚îÇ
‚îÇ   2. IF critical errors found:                              ‚îÇ
‚îÇ      ‚îú‚îÄ Analyze error messages                             ‚îÇ
‚îÇ      ‚îú‚îÄ IF API error:                                       ‚îÇ
‚îÇ      ‚îÇ  ‚îú‚îÄ Call search() or getMember() or info()          ‚îÇ
‚îÇ      ‚îÇ  ‚îî‚îÄ Find correct API                                 ‚îÇ
‚îÇ      ‚îú‚îÄ Apply fixes to code                                 ‚îÇ
‚îÇ      ‚îú‚îÄ Write corrected file                                ‚îÇ
‚îÇ      ‚îî‚îÄ Repeat from step 1 (max 3 iterations)              ‚îÇ
‚îÇ   3. IF errors remain after 3 attempts:                     ‚îÇ
‚îÇ      ‚îú‚îÄ STOP processing                                     ‚îÇ
‚îÇ      ‚îî‚îÄ Escalate to user with error details                ‚îÇ
‚îÇ   4. SUCCESS: 0 critical errors ‚Üí proceed to Step 6         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Step 6: Additional Validation (via 1C Copilot)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   1. Read final file content                                ‚îÇ
‚îÇ   2. Call 1c-copilot-proxy.check_1c_code(code, "syntax")     ‚îÇ
‚îÇ   3. IF issues reported:                                    ‚îÇ
‚îÇ      ‚îî‚îÄ Apply fixes and repeat Steps 5-6                   ‚îÇ
‚îÇ   4. SUCCESS: No issues ‚Üí proceed to Step 7                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Step 7: Report to User                                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Report: "‚úÖ Code validated successfully via:             ‚îÇ
‚îÇ   - search_code() [pattern search]                          ‚îÇ
‚îÇ   - getMembers() [API validation]                           ‚îÇ
‚îÇ   - search_metadata() [metadata validation]                 ‚îÇ
‚îÇ   - read_lints() [linter check: 0 errors]                  ‚îÇ
‚îÇ   - check_1c_code() [additional validation: OK]"           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**ENFORCEMENT:** Agent MUST NOT consider task complete until all steps pass. Zero critical errors is MANDATORY requirement.

---

## Special Cases & Advanced Validation

### 1C Query Language Validation

When writing 1C Query Language code:

```
1. Parse query text
2. Extract ALL object names (tables)
3. FOR EACH object name:
   ‚îî‚îÄ Call search_metadata(op: "object_structure", object: name)
4. Extract ALL field names
5. FOR EACH field:
   ‚îî‚îÄ Verify exists in object structure (from step 3)
6. IF any object/field NOT found:
   ‚îú‚îÄ STOP code generation
   ‚îî‚îÄ Report missing elements to user
7. Write query with validated object and field names
```

**Example:**
```
Query: "–í–´–ë–†–ê–¢–¨ –ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã.–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ, –ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã.–ò–ù–ù –ò–ó –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫.–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã"

Validation steps:
1. Extract object: "–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã"
2. Call search_metadata(op: "object_structure", object: "–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã")
3. Verify fields: "–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ", "–ò–ù–ù" exist in structure
4. IF all verified ‚Üí write query
```

### –ë–°–ü/SSL (Standard Subsystems Library) Code

When working with standard subsystems:

```
1. ALWAYS set is_ssl_api: true in search_code()
2. Search for standard procedures BEFORE writing custom ones
3. Example: File operations ‚Üí search "—Ä–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏" with is_ssl_api: true
4. Prefer standard procedures over custom implementation
```

**Example call:**
```json
{
  "op": "find_routines_by_description",
  "text": "—Ä–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏",
  "is_ssl_api": true,
  "limit": 50
}
```

### Query Strings in Code

When code contains query as string variable:

```
1. Extract query text from string
2. Parse query (identify SELECT, FROM, WHERE clauses)
3. Extract table and field names
4. Validate each name via search_metadata
5. IF validation fails:
   ‚îú‚îÄ STOP
   ‚îî‚îÄ Report invalid names to user
6. Write code with validated query
```

---

## Integration with Existing Rules

This skill complements existing project rules:

### Integration Order

```
1. Skills Index Detection
   ‚îî‚îÄ Keywords detected ‚Üí load 1C_BSL_SKILL

2. Apply Anti-Hallucination Rules (this skill)
   ‚îú‚îÄ NEVER assume API/metadata
   ‚îú‚îÄ ALWAYS validate before write
   ‚îî‚îÄ ALWAYS lint after write

3. Follow TDD Workflow (if AgentMode.rules.md exists)
   ‚îú‚îÄ Write tests first
   ‚îú‚îÄ Implement with validation
   ‚îî‚îÄ Run tests

4. Apply Project-Specific Rules (if project_bsl_rules.mdc exists)
   ‚îú‚îÄ Add required comment blocks
   ‚îú‚îÄ Update registry.md
   ‚îî‚îÄ Follow DSSL UT conventions
```

### Rule Files Reference

- **project_bsl_rules.mdc** - Change commenting rules (DSSL UT specific)
- **AgentMode.rules.md** - TDD workflow and gate system
- **PlanMode.rules.md** - Planning and specifications
- **1C_BSL_SKILL.md** (this file) - Anti-hallucination validation

**Priority:** Anti-hallucination rules (this skill) are MANDATORY and apply BEFORE any other rules.

---

## Examples

### Example 1: Creating Catalog Write Function

**User request:** "Create function to write Catalog.–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã"

**Agent workflow (MUST follow exactly):**

```
Step 1: Pattern Search
‚úÖ Call: search_code(op: "find_routines_by_description", 
                     text: "–∑–∞–ø–∏—Å—å —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã",
                     is_ssl_api: false, limit: 50)
   Result: Found 3 existing patterns
   Action: Review patterns, select most suitable as foundation

Step 2: Metadata Validation
‚úÖ Call: search_metadata_by_description(text: "—Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã")
   Result: Found "–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏.–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã"
‚úÖ Call: search_metadata(op: "object_structure", object: "–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã")
   Result: Structure with attributes: –ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ, –ò–ù–ù, –ö–ü–ü, etc.

Step 3: API Validation
‚úÖ Call: getMembers("–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–û–±—ä–µ–∫—Ç")
   Result: Methods confirmed: –ó–∞–ø–∏—Å–∞—Ç—å(), –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å–°—Å—ã–ª–∫—É–ù–æ–≤–æ–≥–æ(), etc.

Step 4: Write Code
‚úÖ Write function based on:
   - Found pattern (Step 1)
   - Validated metadata structure (Step 2)
   - Confirmed API methods (Step 3)

Step 5: Linter Check
‚úÖ Call: read_lints(["path/to/file.bsl"])
   Result: 0 errors

Step 6: Additional Validation
‚úÖ Call: check_1c_code(code, "syntax")
   Result: OK

Step 7: Report
‚úÖ Report to user: "‚úÖ Code validated via search_code(), search_metadata(),
   getMembers(), read_lints() (0 errors), check_1c_code() (OK)"
```

### Example 2: Writing Query for Catalogs

**User request:** "Write query to get –ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã with –ò–ù–ù"

**Agent workflow (MUST follow exactly):**

```
Step 1: Pattern Search (query patterns)
‚úÖ Call: search_code(op: "find_routines_by_description",
                     text: "–∑–∞–ø—Ä–æ—Å —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã",
                     is_ssl_api: false, limit: 50)
   Result: Found example query patterns

Step 2: Metadata Validation
‚úÖ Call: search_metadata_by_description(text: "—Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã")
   Result: "–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏.–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã"
‚úÖ Call: search_metadata(op: "list_attributes", object: "–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã", limit: 500)
   Result: Attributes list including "–ò–ù–ù"
   Action: Verify "–ò–ù–ù" exists ‚Üí ‚úÖ Confirmed

Step 3: Write Query
‚úÖ Write query with validated names:
   "–í–´–ë–†–ê–¢–¨
   |  –ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã.–°—Å—ã–ª–∫–∞,
   |  –ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã.–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ,
   |  –ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã.–ò–ù–ù
   |–ò–ó
   |  –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫.–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã –ö–ê–ö –ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã
   |–ì–î–ï
   |  –ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã.–ò–ù–ù <> """

Step 4: Validation
‚úÖ Call: read_lints() ‚Üí 0 errors
‚úÖ Call: check_1c_code() ‚Üí OK

Step 5: Report
‚úÖ Report successful validation
```

### Example 3: Linter Error Recovery

**Scenario:** Linter reports error on unknown method

**Agent workflow (MUST follow exactly):**

```
Initial code written:
–ü—Ä–æ—Ü–µ–¥—É—Ä–∞ –ó–∞–ø–∏—Å–∞—Ç—å()
  –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–û–±—ä–µ–∫—Ç.–°–æ—Ö—Ä–∞–Ω–∏—Ç—å–î–∞–Ω–Ω—ã–µ(); // ‚ùå Method doesn't exist!
–ö–æ–Ω–µ—Ü–ü—Ä–æ—Ü–µ–¥—É—Ä—ã

Step 1: Linter detects error
‚úÖ Call: read_lints(["file.bsl"])
   Result: Error "Method '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å–î–∞–Ω–Ω—ã–µ' not found"

Step 2: Reactive API validation
‚úÖ Call: search(query: "save catalog data", type: "method", limit: 10)
   Result: Suggests "–ó–∞–ø–∏—Å–∞—Ç—å()"
‚úÖ Call: getMember("–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–û–±—ä–µ–∫—Ç", "–ó–∞–ø–∏—Å–∞—Ç—å")
   Result: Confirmed signature: –ó–∞–ø–∏—Å–∞—Ç—å()

Step 3: Fix code
‚úÖ Replace: –°–æ—Ö—Ä–∞–Ω–∏—Ç—å–î–∞–Ω–Ω—ã–µ() ‚Üí –ó–∞–ø–∏—Å–∞—Ç—å()

Step 4: Re-validate
‚úÖ Call: read_lints() ‚Üí 0 errors

Step 5: Report
‚úÖ "Error fixed using search() and getMember(). Code now validated."
```

---

## Error Handling & Fallbacks

### If API Not Found

```
1. Report to user: "Method X not found for type Y"
2. Call getMembers(Y) ‚Üí show available alternatives
3. Ask user: "Available methods: [list]. Which should I use?"
4. Wait for user confirmation
5. Use confirmed method
```

**Example:**
```
Agent: "Method '–ù–∞–π—Ç–∏–ü–æ–ö–æ–¥—É' not found for '–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–ú–µ–Ω–µ–¥–∂–µ—Ä'.
       Available methods: –ù–∞–π—Ç–∏–ü–æ–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏—é(), –ù–∞–π—Ç–∏–ü–æ–†–µ–∫–≤–∏–∑–∏—Ç—É().
       Which method should I use for finding by code?"
```

### If Metadata Not Found

```
1. Report to user: "Object X not found in configuration"
2. Call search_metadata_by_description() with similar terms
3. Show similar objects found
4. Ask user: "Did you mean: [list of similar]? Or provide exact name?"
5. Wait for user clarification
6. Use confirmed object name
```

**Example:**
```
Agent: "Object '–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç' not found.
       Similar objects found:
       - –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏.–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã
       - –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏.–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã–ü–æ—Å—Ç–∞–≤—â–∏–∫–∏
       Which one did you mean?"
```

### If Linter Finds Errors (Auto-Fix)

```
1. Display errors to user
2. Attempt automatic fix (max 3 attempts):
   ‚îú‚îÄ Iteration 1: Use search()/getMember() for API errors
   ‚îú‚îÄ Iteration 2: Re-validate metadata if object not found
   ‚îî‚îÄ Iteration 3: Try alternative approach from search_code()
3. IF fixed ‚Üí report success
4. IF not fixed after 3 attempts:
   ‚îú‚îÄ Show remaining errors to user
   ‚îú‚îÄ Explain what was tried
   ‚îî‚îÄ Request user guidance
```

**Example:**
```
Agent: "Linter found 2 errors. Attempting auto-fix...
       Iteration 1: Fixed API call using getMember()
       Iteration 2: Fixed metadata reference using search_metadata()
       ‚úÖ All errors resolved. Code validated."
```

### If Validation Tools Fail

```
IF MCP tool returns error:
1. Log the error
2. Report to user: "Validation tool X failed: [error message]"
3. Explain impact: "Cannot validate Y without tool X"
4. Ask user: "Proceed without validation? (NOT recommended)"
5. IF user approves:
   ‚îî‚îÄ Add comment in code: "// WARNING: Not validated due to tool failure"
6. IF user declines:
   ‚îî‚îÄ STOP and wait for tool to be available
```

---

## Agent Checklist

**Before completing BSL code generation, verify ALL items:**

### Pre-Write Validation
- [ ] Pattern search performed via `search_code()` (if applicable)
- [ ] ALL platform API calls validated via `getMembers()` or `getMember()`
- [ ] ALL metadata objects verified via `search_metadata()` or `search_metadata_by_description()`
- [ ] Object structures validated (attributes, tabular parts confirmed to exist)
- [ ] Query object/field names validated (if writing queries)

### Post-Write Validation
- [ ] File written with validated code
- [ ] `read_lints()` executed ‚Üí 0 critical errors achieved
- [ ] `1c-copilot-proxy.check_1c_code()` executed ‚Üí OK
- [ ] All linter errors fixed (max 3 attempts used if needed)

### Reporting
- [ ] User notified of successful validation
- [ ] List of validation tools used provided to user
- [ ] Any warnings or caveats communicated clearly

### STOP Conditions (DO NOT PROCEED if any true)
- [ ] API validation failed and user has not provided guidance
- [ ] Metadata not found and user has not clarified
- [ ] Linter errors remain after 3 fix attempts
- [ ] Validation tool unavailable and user has not approved proceeding

---

## Summary: The Absolute Rules

1. **NEVER** write code without validating API via `getMembers()`
2. **NEVER** use metadata without verifying via `search_metadata()`
3. **ALWAYS** search for existing patterns via `search_code()` first
4. **ALWAYS** run `read_lints()` immediately after writing file
5. **ALWAYS** achieve 0 critical linter errors before completion
6. **STOP** immediately if validation fails - escalate to user
7. **REPORT** all validation steps performed to user

**These rules are ABSOLUTE. Violations produce hallucinated, broken code.**

---

*This skill ensures code quality and prevents hallucinations through systematic validation. Follow every step without exception.*
